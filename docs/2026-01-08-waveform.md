# Waveform Display

Display audio waveform in piano roll for visual tempo sync.

## Problem

Without seeing the waveform, it's hard to:

1. Align beat grid with actual audio transients
2. Verify tempo is correct
3. See where musical events happen in the backing track

## Features

### 1. Waveform Rendering

- Draw audio peaks as vertical bars or filled polygon
- Sync horizontally with piano roll grid (same zoom/scroll)
- Display above or behind the note grid

### 2. Integration

- Extract peaks from AudioBuffer after loading
- Render in sync with piano roll viewport
- Responsive to horizontal zoom/scroll

## Research: Tone.js

Checked `refs/Tone.js/`:

- `Tone.Waveform` - Real-time analysis (oscilloscope), NOT static overview
- `ToneAudioBuffer` - Has `getChannelData(channel)` for raw samples

No built-in static waveform feature. Must implement peak extraction ourselves.

## Design

### Access Audio Data

```typescript
// After player.load(), access buffer:
const buffer = player.buffer; // ToneAudioBuffer
const samples = buffer.getChannelData(0); // Float32Array
const sampleRate = buffer.sampleRate;
const duration = buffer.duration;
```

### Peak Extraction

```typescript
function extractPeaks(
  samples: Float32Array,
  peaksPerSecond: number,
  sampleRate: number,
): number[] {
  const samplesPerPeak = Math.floor(sampleRate / peaksPerSecond);
  const peaks: number[] = [];

  for (let i = 0; i < samples.length; i += samplesPerPeak) {
    let max = 0;
    const end = Math.min(i + samplesPerPeak, samples.length);
    for (let j = i; j < end; j++) {
      const abs = Math.abs(samples[j]);
      if (abs > max) max = abs;
    }
    peaks.push(max);
  }

  return peaks;
}
```

### Rendering Approach

Option A: Canvas overlay (better performance for large files)
Option B: SVG path (consistent with piano roll, easier styling)

Start with SVG for consistency. Canvas if performance issues.

### Coordinate Mapping

```typescript
// peaks array covers full audio duration
// need to map to piano roll x-coordinates (beats → pixels)

// For each visible pixel column:
// 1. Calculate corresponding time in seconds
// 2. Map to peak index
// 3. Draw peak amplitude as vertical line
```

## Implementation Steps

1. [ ] Add `getPeaks()` method to AudioManager
2. [ ] Store peaks in project store after audio load
3. [ ] Create Waveform component (SVG-based)
4. [ ] Integrate with piano roll viewport (zoom/scroll sync)
5. [ ] Style waveform (color, opacity behind notes)
6. [ ] Test with various audio files

## Files to Modify

| File                            | Changes                  |
| ------------------------------- | ------------------------ |
| `src/lib/audio.ts`              | getPeaks() method        |
| `src/stores/project-store.ts`   | peaks array storage      |
| `src/components/piano-roll.tsx` | Waveform rendering layer |

## UI Sketch

```
Timeline: |----1----|----2----|----3----|----4----|
Waveform: ▁▂▅█▅▂▁▂▃▆█▆▃▁▂▄▇█▇▄▂▁▂▃▅█▅▃▂▁
Notes:    [====]    [==]  [======]    [====]
Keys:  C3|
       B2|
       ...
```

Waveform as semi-transparent layer behind notes.

## Considerations

### Performance

- Pre-compute peaks at load time (one-time cost)
- Resolution: ~200-500 peaks per second is sufficient
- Only render visible portion (virtualized like grid)

### Stereo

- Use mono mix or just left channel for display
- Bass content is usually centered anyway

### Zoom Behavior

- At high zoom, show more detail (more peaks visible)
- At low zoom, aggregate peaks (max of range)

## Status

**Done** - Waveform display implemented

### Completed

- getPeaks() method in AudioManager
- Peaks storage in project store
- Peak extraction on audio load
- Waveform SVG component (mirrored polygon)
- Integrated with WaveformArea in piano roll
- All E2E tests pass

### Notes

- Waveform renders inside the audio region block (green emerald bar)
- Uses SVG path with percentage-based x coordinates for scaling
- Mirrored display (top and bottom from center)
- White semi-transparent fill with subtle stroke
