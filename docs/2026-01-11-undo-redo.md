# Undo/Redo Implementation

## Problem

Users need to undo/redo MIDI editing operations (add, delete, move, resize notes) to recover from mistakes or experiment without fear.

## Requirements

- Support undo/redo for all note editing operations
  - Add note
  - Delete note(s)
  - Move note(s)
  - Resize note (start/end)
- Keyboard shortcuts: Ctrl+Z (undo), Ctrl+Shift+Z (redo)
- Maintain reasonable history depth (e.g., 50 operations)
- Clear history when loading a new project
- Don't track selection changes in history

## Reference Implementation

Looking at `react-midi-editor` (mentioned in references.md) which has undo support, common patterns include:

1. **Command Pattern**: Encapsulate each edit as a command with execute/undo methods
2. **State Snapshots**: Store before/after state for each operation
3. **History Stack**: Maintain undo/redo stacks with max depth

For this implementation, we'll use a **hybrid approach**:

- Store operation types with minimal data needed to reverse them
- Keep operation-specific undo information (e.g., deleted notes, original positions)

## Implementation Approach

### 1. History Store

Create a separate history manager that:

- Tracks operations as they happen
- Maintains undo/redo stacks
- Provides undo/redo actions
- Limits history depth

```typescript
type HistoryEntry =
  | { type: "add-note"; noteId: string; note: Note }
  | { type: "delete-notes"; notes: Note[] }
  | {
      type: "update-notes";
      updates: Array<{
        id: string;
        before: Partial<Note>;
        after: Partial<Note>;
      }>;
    }
  | { type: "batch"; operations: HistoryEntry[] }; // for multi-note operations

interface HistoryState {
  undoStack: HistoryEntry[];
  redoStack: HistoryEntry[];
  maxHistory: number;
  canUndo: boolean;
  canRedo: boolean;
  undo: () => void;
  redo: () => void;
  pushOperation: (entry: HistoryEntry) => void;
  clearHistory: () => void;
}
```

### 2. Integration with Project Store

Modify store actions to record history:

- `addNote` → push to history before adding
- `deleteNotes` → save deleted notes before removal
- `updateNote` → save before/after state

Use a flag to prevent recursive history tracking during undo/redo operations.

### 3. Batch Operations

For operations that affect multiple notes (e.g., moving selection), group them into a single history entry to undo/redo atomically.

### 4. Keyboard Shortcuts

Add to keybindings.ts and wire up in piano-roll.tsx:

- Ctrl+Z: undo
- Ctrl+Shift+Z: redo (primary)
- Ctrl+Y: redo (alternative)

### 5. Edge Cases

- **Undo after selection change**: Should restore notes but not selection state
- **Undo/redo during playback**: Allow, but consider pausing for clarity
- **History after project load**: Clear history on project load/clear
- **Maximum history depth**: Discard oldest entries when limit reached

## Testing Strategy

### Unit Tests

- History stack operations (push, undo, redo, clear)
- Max history limit enforcement
- Batch operation handling

### E2E Tests

- Create note → undo → verify note removed
- Delete note → undo → verify note restored
- Move note → undo → verify original position
- Resize note → undo → verify original size
- Multiple operations → undo sequence → verify each step
- Redo after undo
- Undo/redo keyboard shortcuts

## Files to Modify

- `src/stores/project-store.ts` - Add history tracking to actions
- `src/stores/history-store.ts` - New file for history management
- `src/lib/keybindings.ts` - Add undo/redo shortcuts
- `src/components/piano-roll.tsx` - Wire up keyboard shortcuts
- `e2e/undo-redo.spec.ts` - New E2E tests
- `src/stores/history-store.test.ts` - New unit tests (optional, if needed)

## Status

- [x] Task document created
- [ ] Implement history store
- [ ] Integrate with project store actions
- [ ] Add keyboard shortcuts
- [ ] Write tests
- [ ] Manual verification
- [ ] Code review
